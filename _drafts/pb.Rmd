---
title: "What is the cost of a progress bar in R?"
layout: default
published: false
category: Code
tags: [R, pbapply, progress bar]
disqus: petersolymos
promote: false
output: 
  pdf_document:
    keep_tex: true
---

```{r preamble,echo=FALSE}
knitr::opts_chunk$set(dev=c('png','pdf'),cache=TRUE,message=FALSE,warning=FALSE)
```

The [**pbapply**](http://cran.r-project.org/package=pbapply) R package
adds progress bar to vectorized functions, like `lapply`.
A [feature request](https://github.com/psolymos/pbapply/issues/9)
regarding progress bar for parallel functions has been sitting
at the development GitHub repo for a few months.
The author of the [**pbmcapply**](https://cran.r-project.org/web/packages/pbmcapply/index.html)
package dropped a note about his implementation of forking functionality
with progress bar for Unix/Linux computers, which got me thinking.
How should we add progress bar to snow type clusters? Which led to
another and perhaps more important question: how can we
reduce the progress bar overhead on process times?

Describe how parLapply works for splitting

Describe how pb works, and how splitpb works

Do some benchmarking (nout=NULL) -- table output

Problem: need to cap pb updates (examples: rjags, vegan)

Show results for nout: 500,200,100,50,25

Solution: use nout=100 as default as part of pboptions

Emphasize that this fixed overhead remains constant, old implementation depended on problem size.

```{r pre}
library(pbapply)
library(parallel)
library(pbmcapply)

ncl <- 2
n <- 5000
B <- 1000

set.seed(1234)
x <- rnorm(n)
y <- rnorm(n, crossprod(t(model.matrix(~ x)), c(0, 1)), sd = 0.5)
d <- data.frame(y, x)

mod <- lm(y ~ x, d)
ndat <- model.frame(mod)
bid <- sapply(1:B, function(i) sample(nrow(ndat), nrow(ndat), TRUE))
fun <- function(z) {
    if (missing(z))
        z <- sample(nrow(ndat), nrow(ndat), TRUE)
    coef(lm(mod$call$formula, data=ndat[z,]))
}
#Sys.sleep(0.1)

pblapply_test <-
function (X, FUN, ..., cl = NULL, nout = NULL)
{
    FUN <- match.fun(FUN)
    if (!is.vector(X) || is.object(X))
        X <- as.list(X)
    ## catch single node requests and forking on Windows
    if (!is.null(cl)) {
        if (inherits(cl, "cluster") && length(cl) < 2L)
            cl <- NULL
        if (!inherits(cl, "cluster") && cl < 2)
            cl <- NULL
        if (!inherits(cl, "cluster") && .Platform$OS.type == "windows")
            cl <- NULL
    }
    ## sequential evaluation
    if (is.null(cl)) {
        if (!dopb())
            return(lapply(X, FUN, ...))
        Split <- splitpb(length(X), 1L, nout = nout)
        B <- length(Split)
        pb <- startpb(0, B)
        on.exit(closepb(pb), add = TRUE)
        rval <- vector("list", B)
        for (i in seq_len(B)) {
            rval[i] <- list(lapply(X[Split[[i]]], FUN, ...))
            setpb(pb, i)
        }
    ## parallel evaluation
    } else {
        ## snow type cluster
        if (inherits(cl, "cluster")) {
            if (!dopb())
                return(parallel::parLapply(cl, X, FUN, ...))
            ## define split here and use that for counter
            Split <- splitpb(length(X), length(cl), nout = nout)
            B <- length(Split)
            pb <- startpb(0, B)
            on.exit(closepb(pb), add = TRUE)
            rval <- vector("list", B)
            for (i in seq_len(B)) {
                rval[i] <- list(parallel::parLapply(cl, X[Split[[i]]], FUN, ...))
                setpb(pb, i)
            }
        ## multicore type forking
        } else {
            if (!dopb())
                return(parallel::mclapply(X, FUN, ..., mc.cores = as.integer(cl)))
            ## define split here and use that for counter
            Split <- splitpb(length(X), as.integer(cl), nout = nout)
            B <- length(Split)
            pb <- startpb(0, B)
            on.exit(closepb(pb), add = TRUE)
            rval <- vector("list", B)
            for (i in seq_len(B)) {
                rval[i] <- list(parallel::mclapply(X[Split[[i]]], FUN, ...,
                    mc.cores = as.integer(cl)))
                setpb(pb, i)
            }
        }
    }
    ## assemble output list
    rval <- do.call(c, rval, quote = TRUE)
    names(rval) <- names(X)
    rval
}

timer_fun <- function(type = "timer") {
    pbo <- pboptions(type = type)
    on.exit(pboptions(pbo))
    rbind(
#        lapply = system.time(lapply(1:B, function(i) 
#            fun(bid[,i]))),
#        parLapply = system.time(parLapply(cl = cl, 1:B, 
#            function(i) fun(bid[,i]))),
#        mclapply = system.time(mclapply(1:B, function(i) 
#            fun(bid[,i]), mc.cores = ncl)),
#        pbmclapply = system.time(pbmclapply(1:B, function(i) 
#            fun(bid[,i]), mc.cores = ncl)),

        pb_NULL = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), nout = NULL)),
        pb_100 = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), nout = 100)),
        pb_50 = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), nout = 50)),
        pb_25 = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), nout = 25)),

        pb_cl_NULL = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), cl = cl, nout = NULL)),
        pb_cl_100 = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), cl = cl, nout = 100)),
        pb_cl_50 = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), cl = cl, nout = 50)),
        pb_cl_25 = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), cl = cl, nout = 25)),

        pb_mc_NULL = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), cl = ncl, nout = NULL)),
        pb_mc_100 = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), cl = ncl, nout = 100)),
        pb_mc_50 = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), cl = ncl, nout = 50)),
        pb_mc_25 = system.time(pblapply_test(1:B, function(i) 
            fun(bid[,i]), cl = ncl, nout = 25))
    )
}
```

```{r calc,results="hide"}
cl <- makeCluster(ncl)
clusterExport(cl, c("fun", "mod", "ndat", "bid"))
timer_out_1 <- list(
    none = timer_fun("none"),
    txt = timer_fun("txt"),
    timer = timer_fun("timer"))
if (FALSE) {
timer_out_2 <- list(
    none = timer_fun("none"),
    txt = timer_fun("txt"),
    timer = timer_fun("timer"))
timer_out_3 <- list(
    none = timer_fun("none"),
    txt = timer_fun("txt"),
    timer = timer_fun("timer"))
timer_out <- list()
timer_out[["none"]] <- (timer_out_1[[1]] + timer_out_2[[1]] + 
    timer_out_3[[1]]) / 3
timer_out[["txt"]] <- (timer_out_1[[2]] + timer_out_2[[2]] + 
    timer_out_3[[2]]) / 3
timer_out[["timer"]] <- (timer_out_1[[3]] + timer_out_2[[3]] + 
    timer_out_3[[3]]) / 3
tpbmc <- rowMeans(replicate(3, system.time(pbmclapply(1:B, function(i) 
    fun(bid[,i]), mc.cores = ncl))))
}
stopCluster(cl)

timer_out <- timer_out_1
tpbmc <- system.time(pbmclapply(1:B, function(i) 
    fun(bid[,i]), mc.cores = ncl))
```

```{r pb_matplot,fig.height=4,fig.width=10}
npb <- c(B/ncl, 100, 50, 25)
tpb <- cbind(timer_out[[1]][1:4,3], 
    timer_out[[2]][1:4,3], 
    timer_out[[3]][1:4,3])
tcl <- cbind(timer_out[[1]][5:8,3], 
    timer_out[[2]][5:8,3], 
    timer_out[[3]][5:8,3])
tmc <- cbind(timer_out[[1]][9:12,3], 
    timer_out[[2]][9:12,3], 
    timer_out[[3]][9:12,3])
colnames(tpb) <- colnames(tcl) <- colnames(tmc) <- names(timer_out)

op <- par(mfrow = c(1, 3), las = 1, mar = c(5, 5, 2, 2))
matplot(npb, tpb, type = "l", lty = 1, ylim = c(0, max(tpb, tcl, tmc)),
    xlab = "# pb updates", ylab = "proc time (sec)", main = "sequential")
matplot(npb, tcl, type = "l", lty = 1, ylim = c(0, max(tpb, tcl, tmc)),
    xlab = "# pb updates", ylab = "proc time (sec)", main = "cluster")
matplot(npb, tmc, type = "l", lty = 1, ylim = c(0, max(tpb, tcl, tmc)),
    xlab = "# pb updates", ylab = "proc time (sec)", main = "forking")
abline(h = tpbmc[3], lty = 2, col = 2)
legend("bottomleft", bty = "n", lty = c(1, 1, 1, 2), col = c(1:3, 2),
    legend = c(names(timer_out), "pbmclapply"))
par(op)
```
